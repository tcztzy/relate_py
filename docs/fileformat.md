# Input data file format

The input file format for **Relate** is the haps/sample file format, which is used as an output file format by [SHAPEIT2][].

### `.haps`

### `.sample`

## Other file format may used

### `.fasta`/`.fastq` (used by [LDhat][])
The first line in a FASTA file started either with a ">" (greater-than, 003E) symbol or, less frequently, a ";" (semicolon, 003B) was taken as a comment.
Subsequent lines starting with a semicolon would be ignored by software.
Since the only comment used was the first, it quickly became used to hold a summary description of the sequence, often starting with a unique library accession number, and with time it has become commonplace to always use ">" for the first line and to not use ";" comments (which would otherwise be ignored).

Following the initial line (used for a unique description of the sequence) was the actual sequence itself in standard one-letter character string.
Anything other than a valid character would be ignored (including spaces, tabulators, asterisks, etc...).
It was also common to end the sequence with an "*" (asterisk, 002A) character (in analogy with use in PIR formatted sequences) and, for the same reason, to leave a blank line between the description and the sequence. Below are a few sample sequences:

```
;LCBO - Prolactin precursor - Bovine
; a sample sequence in FASTA format
MDSKGSSQKGSRLLLLLVVSNLLLCQGVVSTPVCPNGPGNCQVSLRDLFDRAVMVSHYIHDLSS
EMFNEFDKRYAQGKGFITMALNSCHTSSLPTPEDKEQAQQTHHEVLMSLILGLLRSWNDPLYHL
VTEVRGMKGAPDAILSRAIEIEEENKRLLEGMEMIFGQVIPGAKETEPYPVWSGLPSLQTKDED
ARYSAFYNLLHCLRRDSSKIDTYLKLLNCRIIYNNNC*

>MCHU - Calmodulin - Human, rabbit, bovine, rat, and chicken
MADQLTEEQIAEFKEAFSLFDKDGDGTITTKELGTVMRSLGQNPTEAELQDMINEVDADGNGTID
FPEFLTMMARKMKDTDSEEEIREAFRVFDKDGNGYISAAELRHVMTNLGEKLTDEEVDEMIREA
DIDGDGQVNYEEFVQMMTAK*

>gi|5524211|gb|AAD44166.1| cytochrome b [Elephas maximus maximus]
LCLYTHIGRNIYYGSYLYSETWNTGIMLLLITMATAFMGYVLPWGQMSFWGATVITNLFSAIPYIGTNLV
EWIWGGFSVDKATLNRFFAFHFILPFTMVALAGVHLTFLHETGSNNPLGLTSDSDKIPFHPYYTIKDFLG
LLILILLLLLLALLSPDMLGDPDNHMPADPLNTPLHIKPEWYFLFAYAILRSVPNKLGGVLALFLSIVIL
GLMPFLHTSKHRSMMLRPLSQALFWTLTMDLLTLTWIGSQPVEYPYTIIGQMASILYFSIILAFLPIAGX
IENY
```
A multiple sequence FASTA format would be obtained by concatenating several single sequence FASTA files in a common file (also known as multi-FASTA format).
This does not imply a contradiction with the format as only the first line in a FASTA file may start with a ";" or ">", hence forcing all subsequent sequences to start with a ">" in order to be taken as different ones (and further forcing the exclusive reservation of ">" for the sequence definition line).
Thus, the examples above may as well be taken as a multisequence (i.e multi-FASTA) file if taken together.

Nowadays, modern bioinformatic programs that rely on the FASTA format expect the sequence headers to be preceded by ">", and the actual sequence, while generally represented as "interleaved", i.e. on multiple lines as in the above example, may also be "sequential" when the full stretch is found on a single line.
Users may often need to perform conversion between "Sequential" and "Interleaved" FASTA format to run different bioinformatic programs.

### `.sam`/`.bam` (our source data format)
Sequence Alignment Map (SAM) is a text-based format originally for storing biological sequences aligned to a reference sequence developed by Heng Li and Bob Handsaker et al.[<sup>[1]</sup>](https://doi.org/10.1093%2Fbioinformatics%2Fbtp352)
It was developed when the 1000 Genomes Project wanted to move away from the MAQ mapper format and decided to design a new format.
The overall TAB-delimited flavour of the format came from an earlier format inspired by BLAT’s PSL.
The name of SAM came from Gabor Marth from University of Utah, who originally had a format under the same name but with a different syntax more similar to a BLAST output.[2]
It is widely used for storing data, such as nucleotide sequences, generated by next generation sequencing technologies, and the standard has been broadened to include unmapped sequences.[3]
The format supports short and long reads (up to 128 Mbp) produced by different sequencing platforms and is used to hold mapped data within the Genome Analysis Toolkit (GATK) and across the Broad Institute, the Wellcome Sanger Institute, and throughout the 1000 Genomes Project.


Col|Field|Type  |Brief description
---|-----|------|-------------------------------------
1  |QNAME|String|Query template NAME
2  |FLAG |Int   |bitwise FLAG
3  |RNAME|String|References sequence NAME
4  |POS  |Int   |1- based leftmost mapping POSition
5  |MAPQ |Int   |MAPping Quality
6  |CIGAR|String|CIGAR string
7  |RNEXT|String|Ref. name of the mate/next read
8  |PNEXT|Int   |Position of the mate/next read
9  |TLEN |Int   |observed Template LENgth
10 |SEQ  |String|segment SEQuence
11 |QUAL |String|ASCII of Phred-scaled base QUALity+33


From the specification:[4]

1. QNAME: Query template NAME. Reads/segments having identical QNAME are regarded to come from the same template. A QNAME ‘*’ indicates the information is unavailable. In a SAM file, a read may occupy multiple alignment lines, when its alignment is chimeric or when multiple mappings are given.
2. FLAG: Combination of bitwise FLAGs[5]
3. RNAME: Reference sequence NAME of the alignment. If @SQ header lines are present, RNAME (if not ‘*’) must be present in one of the SQ-SN tag. An unmapped segment without coordinate has a ‘*’ at this field. However, an unmapped segment may also have an ordinary coordinate such that it can be placed at a desired position after sorting. If RNAME is ‘*’, no assumptions can be made about POS and CIGAR.
4. POS: 1-based leftmost mapping POSition of the first matching base. The first base in a reference sequence has coordinate 1. POS is set as 0 for an unmapped read without coordinate. If POS is 0, no assumptions can be made about RNAME and CIGAR.
5. MAPQ: MAPping Quality. It equals −10 log10 Pr{mapping position is wrong}, rounded to the nearest integer. A value 255 indicates that the mapping quality is not available.
6. CIGAR: Concise Idiosyncratic Gapped Alignment Report (CIGAR) string.
7. RNEXT: Reference sequence name of the primary alignment of the NEXT read in the template. For the last read, the next read is the first read in the template. If @SQ header lines are present, RNEXT (if not ‘*’ or ‘=’) must be present in one of the SQ-SN tag. This field is set as ‘*’ when the information is unavailable, and set as ‘=’ if RNEXT is identical RNAME. If not ‘=’ and the next read in the template has one primary mapping (see also bit 0x100 in FLAG), this field is identical to RNAME at the primary line of the next read. If RNEXT is ‘*’, no assumptions can be made on PNEXT and bit 0x20.
8. PNEXT: Position of the primary alignment of the NEXT read in the template. Set as 0 when the information is unavailable. This field equals POS at the primary line of the next read. If PNEXT is 0, no assumptions can be made on RNEXT and bit 0x20.
9. TLEN: signed observed Template LENgth. If all segments are mapped to the same reference, the unsigned observed template length equals the number of bases from the leftmost mapped base to the rightmost mapped base. The leftmost segment has a plus sign and the rightmost has a minus sign. The sign of segments in the middle is undefined. It is set as 0 for single-segment template or when the information is unavailable.
10. SEQ: segment SEQuence. This field can be a ‘*’ when the sequence is not stored. If not a ‘*’, the length of the sequence must equal the sum of lengths of M/I/S/=/X operations in CIGAR. An ‘=’ denotes the base is identical to the reference base. No assumptions can be made on the letter cases.
11. QUAL: ASCII of base QUALity plus 33 (same as the quality string in the Sanger FASTQ format). A base quality is the phred-scaled base error probability which equals −10 log10 Pr{base is wrong}. This field can be a ‘*’ when quality is not stored. If not a ‘*’, SEQ must not be a ‘*’ and the length of the quality string ought to equal the length of SEQ.

The FLAG field is displayed as a single integer, but is the sum of bitwise flags to denote multiple attributes of a read alignment.[4] Each attribute denotes one bit in the binary representation of the integer.

#### Bitwise Flags
|Integer|   Binary   |Description (Paired Read Interpretation)|
|-------|:----------:|----------------------------------------|
|1      |000000000001|template having multiple templates in sequencing (read is paired)|
|2      |000000000010|each segment properly aligned according to the aligner (read mapped in proper pair)|
|4      |000000000100|segment unmapped (read1 unmapped)|
|8      |000000001000|next segment in the template unmapped (read2 unmapped)|
|16     |000000010000|SEQ being reverse complemented (read1 reverse complemented)
|32     |000000100000|SEQ of the next segment in the template being reverse complemented (read2 reverse complemented)
|64     |000001000000|the first segment in the template (is read1)
|128    |000010000000|the last segment in the template (is read2)
|256    |000100000000|not primary alignment
|512    |001000000000|alignment fails quality checks
|1024   |010000000000|PCR or optical duplicate
|2048   |100000000000|supplementary alignment (e.g. aligner specific, could be a portion of a split read or a tied region)

### `.vcf`/`.bcf` (used by [RelateFileFormats][])


## File formats conversion
[from `.bam` to `.fasta`](https://www.biostars.org/p/6970/)

```python
import os
import sys

import pysam
from Bio import SeqIO, Seq, SeqRecord

def main(in_file):
    out_file = "%s.fa" % os.path.splitext(in_file)[0]
    with open(out_file, "w") as out_handle:
        # Write records from the BAM file one at a time to the output file.
        # Works lazily as BAM sequences are read so will handle large files.
        SeqIO.write(bam_to_rec(in_file), out_handle, "fasta")

def bam_to_rec(in_file):
    """Generator to convert BAM files into Biopython SeqRecords.
    """
    bam_file = pysam.Samfile(in_file, "rb")
    for read in bam_file:
        seq = Seq.Seq(read.seq)
        if read.is_reverse:
            seq = seq.reverse_complement()
        rec = SeqRecord.SeqRecord(seq, read.qname, "", "")
        yield rec

if __name__ == "__main__":
    main(*sys.argv[1:])
```

```{note} The previous code should be compiled with Cython, otherwise it takes about 5x time.
```

[from `.bam` to `.vcf`](http://www.htslib.org/workflow/wgs-call.html)
```console
$ bcftools mpileup -Ou -f <ref.fa> <sample1.bam> <sample2.bam> <sample3.bam> | bcftools call -vmO z -o <study.vcf.gz>
```
[from `.vcf` to `.haps`/`.sample`](https://myersgroup.github.io/relate/input_data.html#ConvertFromVcf)
```console
$ $PATH_TO_RELATE/bin/RelateFileFormats \
                 --mode ConvertFromVcf \
                 --haps example.haps \
                 --sample example.sample \
                 -i example 
```

[from ms output format to `.haps`/`.sample`](https://myersgroup.github.io/relate/input_data.html#ConvertFromMs)

```console
$ Rscript ms2haps.R infile.ms example nsites
```

[SHAPEIT2]: http://www.shapeit.fr/pages/m02_formats/hapssample.html
[LDhat]: https://github.com/auton1/LDhat
[RelateFileFormats]: https://myersgroup.github.io/relate/input_data.html#ConvertFromVcf
[.haps]: https://www.cog-genomics.org/plink/2.0/formats#haps
